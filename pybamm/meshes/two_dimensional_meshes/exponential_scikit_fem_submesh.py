#
# Exponential scikit-fem mesh for use in PyBaMM
#
import pybamm
from .base_scikit_fem_submesh import ScikitSubMesh2D

import numpy as np


class ScikitTopExponential2DSubMesh(ScikitSubMesh2D):
    """
    Contains information about the 2D finite element mesh generated by taking the
    tensor product of a uniformly spaced grid in the y direction, and a unequally
    spaced grid in the z direction in which the points are clustered
    close to the top boundary using an exponential formula on the interval [a,b].
    The gridpoints in the z direction are given by

   .. math::
    z_{k} = (b-a) + \\frac{\\exp{-\\alpha k / N} - 1}{\\exp{-\\alpha} - 1}} + a,

    for k = 1, ..., N, where N is the number of nodes. Here alpha is
    a stretching factor. As the number of gridpoints tends to infinity, the ratio
    of the largest and smallest grid cells tends to exp(alpha).

    Parameters
    ----------
    lims : dict
        A dictionary that contains the limits of each
        spatial variable
    npts : dict
        A dictionary that contains the number of points to be used on each
        spatial variable
    tabs : dict
        A dictionary that contains information about the size and location of
        the tabs
    """

    def __init__(self, lims, npts, tabs):

        # check that two variables have been passed in
        if len(lims) != 2:
            raise pybamm.GeometryError(
                "lims should contain exactly two variables, not {}".format(len(lims))
            )

        # get spatial variables
        spatial_vars = list(lims.keys())

        # check coordinate system agrees
        if spatial_vars[0].coord_sys == spatial_vars[1].coord_sys:
            coord_sys = spatial_vars[0].coord_sys
        else:
            raise pybamm.DomainError(
                """spatial variables should have the same coordinate system,
                but have coordinate systems {} and {}""".format(
                    spatial_vars[0].coord_sys, spatial_vars[1].coord_sys
                )
            )

        # compute edges
        edges = {}
        for var in spatial_vars:
            if var.name not in ["y", "z"]:
                raise pybamm.DomainError(
                    "spatial variable must be y or z not {}".format(var.name)
                )
            elif var.name == "y":
                edges[var.name] = np.linspace(
                    lims[var]["min"], lims[var]["max"], npts[var.id]
                )
            elif var.name == "z":
                # Strech factor. TODO: allow parameters to be passed to mesh
                alpha = 2.3
                ii = np.array(range(0, npts[var.id]))
                a = lims[var]["min"]
                b = lims[var]["max"]
                edges[var.name] = (b - a) * (
                    np.exp(-alpha * ii / (npts[var.id] - 1)) - 1
                ) / (np.exp(-alpha) - 1) + a

        super().__init__(edges, coord_sys, tabs)
